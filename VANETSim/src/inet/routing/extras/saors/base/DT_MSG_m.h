//
// Generated file, do not edit! Created by nedtool 4.6 from routing/extras/saors/base/DT_MSG.msg.
//

#ifndef _INET__INETMANET_DT_MSG_M_H_
#define _INET__INETMANET_DT_MSG_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/networklayer/contract/ipv4/IPv4Address.h"
#include "inet/networklayer/common/IPProtocolId_m.h"
// }}


namespace inet {
namespace inetmanet {

/**
 * Class generated from <tt>routing/extras/saors/base/DT_MSG.msg:48</tt> by nedtool.
 * <pre>
 * //
 * // <b> The Delay Tolerant Message </b>
 * //
 * // This message encapsulated IP Packets, in order to provide delay
 * // tolerant functionality. It include a number of entra fields.
 * // These inlcude the addresses of the transmitted and receiving
 * // nodes, making it possible for this message to be exchanges
 * // between nodes that are neither the source nor the final desitnation
 * // of the encapulated mesage. It also defines the number of copies
 * // of this message that can be made, in order to allow flooding-like
 * // protocols. Finally it defines the IP protocol type, to enable
 * // developement. 
 * //
 * // @see SAORSBase
 * //
 * // @author: Nikolaos Vastardis
 * //
 * packet DT_MSG extends cPacket
 * {
 *     IPv4Address dstAddress;
 *     IPv4Address srcAddress;
 *     uint8_t copiesLeft;
 *     bool isCopy;
 *     uint8_t transportProtocol @enum(IPProtocolId) = IP_PROT_NONE;
 * }
 * </pre>
 */
class DT_MSG : public ::cPacket
{
  protected:
    IPv4Address dstAddress_var;
    IPv4Address srcAddress_var;
    uint8_t copiesLeft_var;
    bool isCopy_var;
    uint8_t transportProtocol_var;

  private:
    void copy(const DT_MSG& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DT_MSG&);

  public:
    DT_MSG(const char *name=NULL, int kind=0);
    DT_MSG(const DT_MSG& other);
    virtual ~DT_MSG();
    DT_MSG& operator=(const DT_MSG& other);
    virtual DT_MSG *dup() const {return new DT_MSG(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPv4Address& getDstAddress();
    virtual const IPv4Address& getDstAddress() const {return const_cast<DT_MSG*>(this)->getDstAddress();}
    virtual void setDstAddress(const IPv4Address& dstAddress);
    virtual IPv4Address& getSrcAddress();
    virtual const IPv4Address& getSrcAddress() const {return const_cast<DT_MSG*>(this)->getSrcAddress();}
    virtual void setSrcAddress(const IPv4Address& srcAddress);
    virtual uint8_t getCopiesLeft() const;
    virtual void setCopiesLeft(uint8_t copiesLeft);
    virtual bool getIsCopy() const;
    virtual void setIsCopy(bool isCopy);
    virtual uint8_t getTransportProtocol() const;
    virtual void setTransportProtocol(uint8_t transportProtocol);
};

inline void doPacking(cCommBuffer *b, DT_MSG& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DT_MSG& obj) {obj.parsimUnpack(b);}

} // namespace inetmanet
} // namespace inet

#endif // ifndef _INET__INETMANET_DT_MSG_M_H_

