//
// Generated file, do not edit! Created by nedtool 4.6 from inet/securityModule/message/securityPkt.msg.
//

#ifndef _SECURITYPKT_M_H_
#define _SECURITYPKT_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "INETDefs.h"
// }}

// cplusplus {{
#include "MACAddress.h"
#include "Ieee80211MgmtFrames_m.h"
#include "Security.h"
#include "SecurityKeys.h"
#include <iostream>
#include <vector>
// }}

// cplusplus {{
typedef SecurityKeys::nonce nonce;
typedef SecurityKeys::key128 key128;
typedef SecurityKeys::key256 key256;
typedef SecurityKeys::key384 key384;
typedef SecurityKeys::mic mic;
typedef SecurityKeys::unit64_t_ unit64_t_;
// }}

/**
 * Class generated from <tt>inet/securityModule/message/securityPkt.msg:40</tt> by nedtool.
 * <pre>
 * packet SecurityPkt //extends Ieee80211ManagementFrame
 * {
 *     char Descriptor_Type[12];
 *     // char Descriptor_Type=0;
 *     short Key_Info = 0;
 *     short Key_Length = 0;
 *     unit64_t_ Key_RC;
 *     nonce Key_Nonce;
 *     key128 EAPOL_KeyIV;
 *     unit64_t_ Key_RSC = 0; //Key Replay Conter
 *     unit64_t_ Reserved = 0;
 *     key128 Mic;
 *     short Key_Data_Length = 0;
 * 
 *     key128 Key_Data128;
 *     key256 Key_Data256;
 * }
 * </pre>
 */
class SecurityPkt : public ::cPacket
{
  protected:
    char Descriptor_Type_var[12];
    short Key_Info_var;
    short Key_Length_var;
    unit64_t_ Key_RC_var;
    nonce Key_Nonce_var;
    key128 EAPOL_KeyIV_var;
    unit64_t_ Key_RSC_var;
    unit64_t_ Reserved_var;
    key128 Mic_var;
    short Key_Data_Length_var;
    key128 Key_Data128_var;
    key256 Key_Data256_var;

  private:
    void copy(const SecurityPkt& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SecurityPkt&);

  public:
    SecurityPkt(const char *name=NULL, int kind=0);
    SecurityPkt(const SecurityPkt& other);
    virtual ~SecurityPkt();
    SecurityPkt& operator=(const SecurityPkt& other);
    virtual SecurityPkt *dup() const {return new SecurityPkt(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getDescriptor_TypeArraySize() const;
    virtual char getDescriptor_Type(unsigned int k) const;
    virtual void setDescriptor_Type(unsigned int k, char Descriptor_Type);
    virtual short getKey_Info() const;
    virtual void setKey_Info(short Key_Info);
    virtual short getKey_Length() const;
    virtual void setKey_Length(short Key_Length);
    virtual unit64_t_& getKey_RC();
    virtual const unit64_t_& getKey_RC() const {return const_cast<SecurityPkt*>(this)->getKey_RC();}
    virtual void setKey_RC(const unit64_t_& Key_RC);
    virtual nonce& getKey_Nonce();
    virtual const nonce& getKey_Nonce() const {return const_cast<SecurityPkt*>(this)->getKey_Nonce();}
    virtual void setKey_Nonce(const nonce& Key_Nonce);
    virtual key128& getEAPOL_KeyIV();
    virtual const key128& getEAPOL_KeyIV() const {return const_cast<SecurityPkt*>(this)->getEAPOL_KeyIV();}
    virtual void setEAPOL_KeyIV(const key128& EAPOL_KeyIV);
    virtual unit64_t_& getKey_RSC();
    virtual const unit64_t_& getKey_RSC() const {return const_cast<SecurityPkt*>(this)->getKey_RSC();}
    virtual void setKey_RSC(const unit64_t_& Key_RSC);
    virtual unit64_t_& getReserved();
    virtual const unit64_t_& getReserved() const {return const_cast<SecurityPkt*>(this)->getReserved();}
    virtual void setReserved(const unit64_t_& Reserved);
    virtual key128& getMic();
    virtual const key128& getMic() const {return const_cast<SecurityPkt*>(this)->getMic();}
    virtual void setMic(const key128& Mic);
    virtual short getKey_Data_Length() const;
    virtual void setKey_Data_Length(short Key_Data_Length);
    virtual key128& getKey_Data128();
    virtual const key128& getKey_Data128() const {return const_cast<SecurityPkt*>(this)->getKey_Data128();}
    virtual void setKey_Data128(const key128& Key_Data128);
    virtual key256& getKey_Data256();
    virtual const key256& getKey_Data256() const {return const_cast<SecurityPkt*>(this)->getKey_Data256();}
    virtual void setKey_Data256(const key256& Key_Data256);
};

inline void doPacking(cCommBuffer *b, SecurityPkt& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SecurityPkt& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/securityModule/message/securityPkt.msg:60</tt> by nedtool.
 * <pre>
 * // Ieee80211DataFrame
 * packet CCMPFrame //extends Ieee80211MeshFrame
 * {
 *     unit64_t_ CCMP_Header; //8 octets
 *     unit64_t_ CCMP_Mic;
 *   //  key128 encryptedData128;  
 * }
 * </pre>
 */
class CCMPFrame : public ::cPacket
{
  protected:
    unit64_t_ CCMP_Header_var;
    unit64_t_ CCMP_Mic_var;

  private:
    void copy(const CCMPFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CCMPFrame&);

  public:
    CCMPFrame(const char *name=NULL, int kind=0);
    CCMPFrame(const CCMPFrame& other);
    virtual ~CCMPFrame();
    CCMPFrame& operator=(const CCMPFrame& other);
    virtual CCMPFrame *dup() const {return new CCMPFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unit64_t_& getCCMP_Header();
    virtual const unit64_t_& getCCMP_Header() const {return const_cast<CCMPFrame*>(this)->getCCMP_Header();}
    virtual void setCCMP_Header(const unit64_t_& CCMP_Header);
    virtual unit64_t_& getCCMP_Mic();
    virtual const unit64_t_& getCCMP_Mic() const {return const_cast<CCMPFrame*>(this)->getCCMP_Mic();}
    virtual void setCCMP_Mic(const unit64_t_& CCMP_Mic);
};

inline void doPacking(cCommBuffer *b, CCMPFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CCMPFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/securityModule/message/securityPkt.msg:67</tt> by nedtool.
 * <pre>
 * packet SAEMsg
 * {
 *     short SAE_sendConfirm;
 *     int SAE_commitScalar;
 *     int SAE_commitElement;
 *     int SAE_confirmfield;
 *     short SAE_finiteCyclicGroup;
 * }
 * </pre>
 */
class SAEMsg : public ::cPacket
{
  protected:
    short SAE_sendConfirm_var;
    int SAE_commitScalar_var;
    int SAE_commitElement_var;
    int SAE_confirmfield_var;
    short SAE_finiteCyclicGroup_var;

  private:
    void copy(const SAEMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SAEMsg&);

  public:
    SAEMsg(const char *name=NULL, int kind=0);
    SAEMsg(const SAEMsg& other);
    virtual ~SAEMsg();
    SAEMsg& operator=(const SAEMsg& other);
    virtual SAEMsg *dup() const {return new SAEMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getSAE_sendConfirm() const;
    virtual void setSAE_sendConfirm(short SAE_sendConfirm);
    virtual int getSAE_commitScalar() const;
    virtual void setSAE_commitScalar(int SAE_commitScalar);
    virtual int getSAE_commitElement() const;
    virtual void setSAE_commitElement(int SAE_commitElement);
    virtual int getSAE_confirmfield() const;
    virtual void setSAE_confirmfield(int SAE_confirmfield);
    virtual short getSAE_finiteCyclicGroup() const;
    virtual void setSAE_finiteCyclicGroup(short SAE_finiteCyclicGroup);
};

inline void doPacking(cCommBuffer *b, SAEMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SAEMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/securityModule/message/securityPkt.msg:76</tt> by nedtool.
 * <pre>
 * packet AMPEMsg //extends Ieee80211ManagementFrame
 * {
 *     key128 Key_Data128;
 *     int sec = 1;
 * }
 * </pre>
 */
class AMPEMsg : public ::cPacket
{
  protected:
    key128 Key_Data128_var;
    int sec_var;

  private:
    void copy(const AMPEMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AMPEMsg&);

  public:
    AMPEMsg(const char *name=NULL, int kind=0);
    AMPEMsg(const AMPEMsg& other);
    virtual ~AMPEMsg();
    AMPEMsg& operator=(const AMPEMsg& other);
    virtual AMPEMsg *dup() const {return new AMPEMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual key128& getKey_Data128();
    virtual const key128& getKey_Data128() const {return const_cast<AMPEMsg*>(this)->getKey_Data128();}
    virtual void setKey_Data128(const key128& Key_Data128);
    virtual int getSec() const;
    virtual void setSec(int sec);
};

inline void doPacking(cCommBuffer *b, AMPEMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AMPEMsg& obj) {obj.parsimUnpack(b);}


#endif // ifndef _SECURITYPKT_M_H_

